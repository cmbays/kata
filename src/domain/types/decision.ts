import { z } from 'zod/v4';
import { StageCategorySchema } from './stage.js';

/**
 * The kind of non-deterministic judgment an orchestrator made.
 * Each type represents a distinct category of decision that can be
 * analyzed independently by the self-improvement loop.
 */
export const DecisionTypeSchema = z.enum([
  'flavor-selection', // Orchestrator chose which flavors to run for a stage
  'execution-mode', // Sequential vs parallel flavor execution
  'synthesis-approach', // How to synthesize flavor outputs into a stage artifact
  'retry', // Whether to retry a failed step or flavor
  'confidence-gate', // Whether to proceed or require human review
  'capability-analysis', // Orchestrator assessed capability profile for flavor matching
  'gap-assessment', // Orchestrator identified gaps in flavor coverage
]);

export type DecisionType = z.infer<typeof DecisionTypeSchema>;

/**
 * Post-facto outcome record filled in after the decision plays out.
 * All fields are optional because outcomes are recorded asynchronously;
 * at least one field must be set to distinguish a recorded outcome from
 * an empty placeholder.
 */
export const DecisionOutcomeSchema = z
  .object({
    /** Quality of the artifact(s) produced as a result of this decision. */
    artifactQuality: z.enum(['good', 'partial', 'poor']).optional(),
    /** Whether exit gate conditions passed, failed, or were skipped. */
    gateResult: z.enum(['passed', 'failed', 'skipped']).optional(),
    /** Whether downstream work required rework attributable to this decision. */
    reworkRequired: z.boolean().optional(),
    /** Free-text notes about the outcome — useful for nuanced cases. */
    notes: z.string().optional(),
    /** How the decision's output was consumed by downstream stages/decisions. */
    downstreamUsage: z.string().optional(),
    /** Whether and how a user overrode or adjusted the orchestrator's choice. */
    userOverrides: z.string().optional(),
    /** Approximate token cost attributable to this decision's execution. */
    tokenCost: z.number().int().nonnegative().optional(),
  })
  .refine((o) => Object.values(o).some((v) => v !== undefined), {
    message: 'At least one outcome field must be set',
  });

export type DecisionOutcome = z.infer<typeof DecisionOutcomeSchema>;

/**
 * Breakdown of how a score was computed during flavor selection.
 * Enables rich provenance for decision analysis and self-improvement.
 */
export const ScoringBreakdownSchema = z.object({
  /** Raw score before any boosts or rule adjustments. */
  baseScore: z.number().min(0).max(1),
  /** Number of keyword matches that contributed to the base score. */
  keywordHits: z.number().int().nonnegative(),
  /** Additive boost from relevant learnings mentioning this flavor. */
  learningBoost: z.number().nonnegative(),
  /** Adjustments applied by active stage rules (positive or negative). */
  ruleAdjustments: z.number(),
  /** Final clamped score in [0, 1] after all adjustments. */
  finalScore: z.number().min(0).max(1),
});

export type ScoringBreakdown = z.infer<typeof ScoringBreakdownSchema>;

/**
 * A Decision record captures a non-deterministic choice made by an orchestrator.
 * Decisions are the primary input to the self-improvement loop:
 * learning extraction analyzes decision quality over time (not just pass/fail).
 *
 * Decisions are immutable once recorded — outcomes are added via updateOutcome().
 */
export const DecisionSchema = z
  .object({
    /** UUID generated by the registry on record(). */
    id: z.string().uuid(),
    /** Which work mode this decision was made in. */
    stageCategory: StageCategorySchema,
    /** The type of judgment being made. */
    decisionType: DecisionTypeSchema,
    /**
     * Snapshot of contextual information available at decision time.
     * May include bet details, available artifacts, prior decisions, project metadata, etc.
     * Flexible record to accommodate orchestrator-specific context shapes.
     */
    context: z.record(z.string(), z.unknown()),
    /** The choices available to the orchestrator (e.g. flavor names, mode strings). */
    options: z.array(z.string()).min(1),
    /** The option that was chosen. Must be one of the values in options. */
    selection: z.string().min(1),
    /** The orchestrator's reasoning for the selection. */
    reasoning: z.string().min(1),
    /** Confidence in the selection, in range [0, 1]. */
    confidence: z.number().min(0).max(1),
    /** Outcome filled in post-facto after the decision plays out. */
    outcome: DecisionOutcomeSchema.optional(),
    /** ISO 8601 timestamp when the decision was made. */
    decidedAt: z.string().datetime(),
  })
  .superRefine((val, ctx) => {
    if (!val.options.includes(val.selection)) {
      ctx.addIssue({
        code: 'custom',
        path: ['selection'],
        message: `selection "${val.selection}" must be one of the available options: [${val.options.join(', ')}]`,
      });
    }
  });

export type Decision = z.infer<typeof DecisionSchema>;
