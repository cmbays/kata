import { z } from 'zod/v4';
import { StageCategorySchema } from './stage.js';

/**
 * The kind of non-deterministic judgment an orchestrator made.
 * Each type represents a distinct category of decision that can be
 * analyzed independently by the self-improvement loop.
 */
export const DecisionTypeSchema = z.enum([
  'flavor-selection', // Orchestrator chose which flavors to run for a stage
  'execution-mode', // Sequential vs parallel flavor execution
  'synthesis-approach', // How to synthesize flavor outputs into a stage artifact
  'retry', // Whether to retry a failed step or flavor
  'confidence-gate', // Whether to proceed or require human review
]);

export type DecisionType = z.infer<typeof DecisionTypeSchema>;

/**
 * Post-facto outcome record filled in after the decision plays out.
 * All fields are optional because outcomes are recorded asynchronously,
 * potentially long after the decision was made.
 */
export const DecisionOutcomeSchema = z.object({
  /** Quality of the artifact(s) produced as a result of this decision. */
  artifactQuality: z.enum(['good', 'partial', 'poor']).optional(),
  /** Whether exit gate conditions passed, failed, or were skipped. */
  gateResult: z.enum(['passed', 'failed', 'skipped']).optional(),
  /** Whether downstream work required rework attributable to this decision. */
  reworkRequired: z.boolean().optional(),
  /** Free-text notes about the outcome — useful for nuanced cases. */
  notes: z.string().optional(),
});

export type DecisionOutcome = z.infer<typeof DecisionOutcomeSchema>;

/**
 * A Decision record captures a non-deterministic choice made by an orchestrator.
 * Decisions are the primary input to the self-improvement loop:
 * learning extraction analyzes decision quality over time (not just pass/fail).
 *
 * Decisions are immutable once recorded — outcomes are added via updateOutcome().
 */
export const DecisionSchema = z.object({
  /** UUID generated by the registry on record(). */
  id: z.string().uuid(),
  /** Which work mode this decision was made in. */
  stageCategory: StageCategorySchema,
  /** The type of judgment being made. */
  decisionType: DecisionTypeSchema,
  /**
   * Snapshot of contextual information available at decision time.
   * May include bet details, available artifacts, prior decisions, project metadata, etc.
   * Flexible record to accommodate orchestrator-specific context shapes.
   */
  context: z.record(z.string(), z.unknown()),
  /** The choices available to the orchestrator (e.g. flavor names, mode strings). */
  options: z.array(z.string()).min(1),
  /** The option that was chosen. Must be one of the values in options. */
  selection: z.string().min(1),
  /** The orchestrator's reasoning for the selection. */
  reasoning: z.string().min(1),
  /** Confidence in the selection, in range [0, 1]. */
  confidence: z.number().min(0).max(1),
  /** Outcome filled in post-facto after the decision plays out. */
  outcome: DecisionOutcomeSchema.optional(),
  /** ISO 8601 timestamp when the decision was made. */
  decidedAt: z.string().datetime(),
});

export type Decision = z.infer<typeof DecisionSchema>;
